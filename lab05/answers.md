# Ответы

## Упражнение 1

### Сценарий 1

1. Какая комбинация параметров обеспечивает наблюдаемую вами частоту попаданий? Запишите свой ответ в виде «[параметр A], [параметр B]», где два параметра завершают следующий ответ: «Благодаря тому, что [параметр A] в байтах точно равен [параметру B] в байтах». Примечание. Не забывайте, что «размер кеша» — это допустимый параметр, который вы неявно задаете, выбирая размер блока и количество блоков.  

Из-за того, что шаг равен размеру кэша (32 байта), мы всегда обращаемся к одному и тому же блоку в кэше (нулевому).  

2. Какова будет наша частота попаданий, если мы произвольно увеличим количество повторений? Запишите свой ответ в виде десятичной дроби (например, «1,0», если HR равен 100%).  

0, ибо здесь решает шаг в 8, который мы не изменяем.  

3. Как мы можем изменить один параметр программы, чтобы получить максимально возможную частоту попаданий? Запишите ответ в виде «[параметр], [значение]», где [параметр] — это параметр программы, который вы хотите изменить, а [значение] — это значение, на которое вы хотите его изменить. Примечание. Неважно, обращаемся ли мы к одним и тем же элементам массива. Просто дайте нам модификацию параметра программы, которая увеличит количество попаданий. Однако убедитесь, что предложенное вами значение верное.  

Установить шаг в 10. Наглядно:  


| index |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  10  |  11  |  12  |  13  |  14  |  15  |  16  |  17  |  18  |  19  |  20  | ...  |  
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|  
| block |  0  |  0  |  1  |  1  |  2  |  2  |  3  |  3  |  0  |  0  |  1   |   1  |   2  |   2  |   3  |   3  |   0  |   0  |   1  |   1  |   2  | ...  |  

Если взять индексы 0, 10, 20, 30, эти элементы попадают соответственно в нулевой, первый и второй блоки кэша, за первую итерацию внешнего цикла они запишутся, и далее оставшиеся 3 итерации они будут браться из кэша. Соответственно получим попадание в кэш в 75% случаев.  

### Сценарий 2

1. Сколько обращений к памяти приходится на одну итерацию внутреннего цикла (не связанно с числом повторений)?  

2 (сначала чтение, потом запись)

2. Какой повторяющийся шаблон попаданий/промахов? Запишите свой ответ в форме «MMHHMMH» (M -- miss, промах; H -- hit, попадание) и т. д., где ваш ответ представляет собой самый короткий шаблон, который повторяется.  

MHHH

3. Сохраняя все остальное без изменений, к чему приближается наша частота попаданий, когда количество повторений достигает бесконечности? Попробуйте, изменить соответствующий параметр программы и запустить код! Запишите ответ в виде десятичной дроби.  

Стремится к 100%. Весь массив помещается в кэш и после первой итерации просто читается оттуда.

### Сценарий 3

1. Какова частота попаданий в кеш L1? В кеш второго уровня? Общая? Запишите свой ответ в форме «[L1 HR], [L2 HR], [Общая частота сердечных сокращений]», где каждый показатель попадания представляет собой десятичную дробь, округленную до двух знаков.  

В кэш L1 - 0.5, L2 - 0, общая - 0.5  

2. Сколько всего произошло доступов к кешу L1? Сколько из них промахнулись? Запишите свой ответ в виде «[количество обращений к L1], [количество промахов L1]».  

32, 16  

3. Сколько у произошло доступов к кешу L2? СОВЕТ: подумайте, как это связано с кешем L1 (подумайте, что должен делать кеш L1, чтобы мы могли получить доступ к кешу L2)?  

16, к L2 мы обращаемся при промахе в L1, соответственно сколько промахов в L1, столько доступов к L2.  

4. Какой программный параметр позволил бы нам увеличить частоту попаданий L2, но сохранить частоту попаданий L1 на прежнем уровне?  

Количество проходов, ибо после первого весь массив укладывается в кэш второго уровня, так что при повторных итерациях мы бы попадали по нему всегда.  

5. Наши показатели попаданий L1 и L2 уменьшаются (-), остаются прежними (=) или увеличиваются (+), когда мы (1) увеличиваем количество блоков в L1 или (2) увеличиваем размер блока L1? Запишите ответ в виде «[1_L1], [1_L2], [2_L1], [2_L2]» (например, если L1 останется прежним для обеих модификаций, а L2 уменьшится для первой и увеличится для второй, то ответ будет «=, -, =, +»).

    1. При увеличении количества блоков в L1 ситуация не меняется, так как проход всего один, в блок помещается 2 элемента массива и стабильно сначала их записываем в кэш, потом при обращении ко второму попадаем по кэшу.  

    2. Попадания в L1 увеличатся, так как шаг 1, и единожны записав >2 элементов в кэш, несколько следующих итераций будут попадать по нему. Для L2 уменьшится количество обращений (так как реже мажем по кэшу L1), но по-прежнему из-за 1 прохода по второму кэшу не попадаем.

## Упражнение 2  

```
ijk:	n = 1000, 1.551 Gflop/s
ikj:	n = 1000, 0.455 Gflop/s
jik:	n = 1000, 0.760 Gflop/s
jki:	n = 1000, 5.177 Gflop/s
kij:	n = 1000, 0.418 Gflop/s
kji:	n = 1000, 3.853 Gflop/s
```

jki и kji быстрее всего  
В обоих случаях самый внутренний цикл проходит массивы B и C с шагом 1, массив А - с шагом 0

## Упражнение 3 

```
50 20
Testing naive transpose: 0.003 milliseconds
Testing transpose with blocking: 0.004 milliseconds

100 20
Testing naive transpose: 0.016 milliseconds
Testing transpose with blocking: 0.019 milliseconds

200 20
Testing naive transpose: 0.04 milliseconds
Testing transpose with blocking: 0.031 milliseconds

500 20
Testing naive transpose: 0.667 milliseconds
Testing transpose with blocking: 0.605 milliseconds

1000 20
Testing naive transpose: 2.71 milliseconds
Testing transpose with blocking: 2.986 milliseconds

2000 20
Testing naive transpose: 14.519 milliseconds
Testing transpose with blocking: 6.142 milliseconds

5000 20
Testing naive transpose: 173.402 milliseconds
Testing transpose with blocking: 52.299 milliseconds

10000 20
Testing naive transpose: 2064.03 milliseconds
Testing transpose with blocking: 303.743 milliseconds
```

Мы улучшаем пространственную локальность в приёмнике, так как чаще обращаемся к соседним элементам в строке.
